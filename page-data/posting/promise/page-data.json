{"componentChunkName":"component---src-components-posting-tsx","path":"/posting/promise","result":{"data":{"markdownRemark":{"html":"<h2>Promise</h2>\n<p><code>Promise</code>를 알아보기 전에 우선 Promise가 나오게된 이유에 대해서 알아볼 필요가 있다.</p>\n<p>자바스크립트에서는 비동기 요청이 자주 사용되곤 한다.<br>\n비동기식 요청은 처리방식을 병렬로 진행하여 기존 처리와 동시에 진행되는 장점이 있다.<br>\n하지만 비동기가 처리된 후 받아온 데이터를 이용한 처리가 되어야 할 경우 콜백을 이용해 처리하게 되는데 이 형태가 중첩될 경우 콜백헬이 형성되게된다.</p>\n<pre><code class=\"language-javascript\">var count = 1\n\nfunction api (param, callback) {\n  $.get(`/api/${count}`, function(res) {\n    count++\n    $.get(`/api/${count}`, function(res) {\n      count++\n      $.get(`/api/${count}`, function(res) {\n        count++\n        ...\n      })\n    })\n  })\n}\n</code></pre>\n<p>위의 예시가 극단적이긴 하지만 콜백지옥의 예이다.<br>\n이런 콜백지옥 현상을 조금 개선하고자 나온 것이 <code>Promise</code>라고 할 수 있다.</p>\n<pre><code class=\"language-mdn\">Promise는 프로미스가 생성될 때 꼭 알 수 있지는 않은 값을 위한 대리자로,\n비동기 연산이 종료된 이후의 결과값이나 실패 이유를 처리하기 위한 처리기를 연결할 수 있도록 합니다.\n</code></pre>\n<p><code>MDN</code>에서 발췌해온 <code>Promise</code>에 대한 설명이다.<br>\n설명에서처럼 <code>Promise</code>는 비동기처리가 끝난 후 나온 값을 연속해서 처리하기를 도와준다고 할 수 있다.</p>\n<pre><code class=\"language-javascript\">var count = 1\n\nfunction promiseFunction () {\n  return new Promise(function (resolve, reject) {\n    resolve($.get(`/api/${count}`))\n  })\n}\n</code></pre>\n<p>위가 프로미스의 기본적인 형태이다.\n<br>\nPromise는 기본적으로 인스턴스를 생성해서 사용하게된다.\n<br>\n인스턴스 생성시 <code>resolve, reject</code>를 인자로 받는 함수를 파라미터로 받는데 <code>resolve</code>는 비동기처리가 성공했을 경우 호출하여 값 넘겨주는 역할을 하고 <code>reject</code>은 비동기처리가 실패했을 때 넘겨줄 값을 넣어주게된다.</p>\n<p>이제 호출하는 부분을 보면 아래와 같이 수정될 수 있다.</p>\n<pre><code class=\"language-javascript\">var count = 1\n\nfunction promiseFunction () {\n  return new Promise(function (resolve, reject) {\n    $.get(`/api/${count}`, function(res) {\n      resolve(res)\n    })\n  })\n}\n\nfunction api (param, callback) {\n  promiseFunction().then(function() {\n    count++\n    return promiseFunction()\n  }).then(function() {\n    count++\n    return promiseFunction()\n  }).then(function() {\n    count++\n    return promiseFunction()\n  })\n  ...\n}\n</code></pre>\n<p>확실히 위에서 본 뎁스가 계속 깊어지면서 가독성이 낮아지는 형태보다는 보기가 편해졌다.<br>\n앞에서 실행한 비동기 함수에서 <code>Promise</code>를 다시 리턴해주고 <code>then</code>을 통해서 다시 <code>resolve</code>된 값을 받아 연속적으로 다음 함수를 처리할 수 있도록 되는 모습을 볼 수 있다.</p>\n<hr>\n<h3>Promise의 예외처리</h3>\n<p>Promise의 형태와 사용법을 알아봤는데 그렇다면 예외처리는 어떻게 할까?<br>\n보통의 자바스크립트에서 발생하는 예외를 처리하는 방법은 <code>try catch</code>를 이용 할 수 있는데 예시를 보면 아래와 같다.</p>\n<pre><code class=\"language-javascript\">function errorTest() {\n  throw new Error('에러')\n}\n\ntry {\n  errorTest()\n} catch (e) {\n  console.log(e) // Error: 에러 ...\n}\n</code></pre>\n<p>그렇다면 Promise의 예외처리도 <code>try catch</code>를 쓰면될까?</p>\n<pre><code class=\"language-javascript\">function promiseError() {\n  return new Promise(function(resolve, reject) {\n    reject(new Error('에러'))\n  })\n}\n\ntry {\n  promiseError()\n} catch (e) {\n  console.log(e)\n}\n\n// Uncaught (in promise) Error: 에러\n</code></pre>\n<p><code>try catch</code>를 사용해 예외처리를 했지만 콘솔로 찍히는 것은 예외처리가 되지 않았다는 에러이다.<br>\n사실 비동기 처리의 예외처리는 <code>try catch</code> 문으로는 잡을 수 없다.<br>\n그 이유는 비동기이기 때문인데, 풀어서 말하자면 <code>try catch</code>와 비동기 처리가 병렬로 진행되기 때문에 비동기 처리가 끝났을 때는 이미 <code>try catch</code>도 끝난 상태이기 때문이다.</p>\n<p>그래서 Promise에서 예외처리는 <code>.catch</code> 메소드를 이용해서 하게된다.</p>\n<pre><code class=\"language-javascript\">function promiseError() {\n  return new Promise(function(resolve, reject) {\n    reject(new Error('에러'))\n  })\n}\n\npromiseError().catch(function(e) {\n  console.log(e) // Error: 에러 ...\n})\n</code></pre>\n<p>위의 예시와 같이 <code>Promise</code>를 호출하고 <code>.catch</code>를 이용해서 에러처리를 하게되면 <code>Uncaught</code>가 발생하지 않고 제대로 예외처리가 되게된다.</p>","frontmatter":{"date":"2020-10-26","path":"/posting/promise","title":"Javascript 프로미스(Promise)","description":"`Promise`를 알아보기 전에 우선 Promise가 나오게된 이유에 대해서 알아볼 필요가 있다. 자바스크립트에서는 비동기 요청이 자주 사용되곤 한다.","tags":["JS","Basic"]}}},"pageContext":{"pagePath":"/posting/promise"}},"staticQueryHashes":["3454785627","63159454","987710685"]}