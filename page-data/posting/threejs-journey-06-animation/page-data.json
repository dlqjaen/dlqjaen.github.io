{"componentChunkName":"component---src-components-posting-tsx","path":"/posting/threejs-journey-06-animation","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://threejs-journey.xyz/lessons/6\">Link</a></p>\n<ul>\n<li><code>window.requestAnimationFrame</code>을 이용하여 한 프레임 단위로 오브젝트를 움직이고 화면을 랜더링한다.</li>\n<li>위 작업을 반복하게되면 프레임단위로 오브젝트가 움직이는 것 처럼 느껴지며 우리는 애니메이션이 적용되었다고 한다.</li>\n<li>이 처럼 한 프레임 단위를 <code>tick</code> 이라고 한다.</li>\n</ul>\n<pre><code class=\"language-javascript\">const tick = () => { window.requestAnimationFrame(tick) }\ntick()\n</code></pre>\n<p>위 코드처럼 <code>tick</code> 을 실행하게되면 한 틱단위로 <code>tick</code> 함수가 무한히 반복 되는 것을 알 수 있다.</p>\n<p>성능이 좋은 컴퓨터의 경우 틱이 실행되는 횟수가 많고 상대적으로 성능이 떨어지는 컴퓨터의 경우 실행횟수가 적어진다.</p>\n<pre><code class=\"language-javascript\">const tick = () => {\n      mesh.rotation.y += 0.001\n    renderer.render(scene, camera)\n    window.requestAnimationFrame(tick)\n}\ntick()\n</code></pre>\n<p>오브젝트에 회전 값을 변경하고 <code>renderer.render</code> 로 화면의 랜더링을 다시해주면 틱 단위로 오브젝트가 y축을 기준으로 돌아가는 듯한 효과를 줄 수 있다.</p>\n<pre><code class=\"language-javascript\">let time = Date.now()\nconst tick = () => {\n    const currentTime = Date.now()\n    const delayTime = currentTime - time\n    time = currentTime\n      mesh.rotation.y += 0.01 * delayTime\n}\ntick()\n</code></pre>\n<p><code>Date.now()</code> 을 이용하면 현재의 타임스탬프를 구할 수 있다. 함수 실행전과 중에 각각 타임스템프를 구해서 그 차이만큼의 값을 이용해서도 오브젝트를 움직일 수 있다.</p>\n<p>시간으로 계산하기에 컴퓨터 성능에 영향을 받는 <code>requestAnimationFrame</code> 와는 달리 시간을 기준으로 하기때문에 거의 모든 컴퓨터에서 동일하게 동작한다.</p>\n<pre><code class=\"language-javascript\">const clock = new THREE.Clock()\nconst tick = () => {\n    const elapsedTime = clock.getElapsedTime()\n\n    mesh.rotation.y = elapsedTime\n}\n\ntick()\n</code></pre>\n<p>Three.js에서 내부적으로 시간 계산을 도와주는 객체가 있다.</p>\n<p><code>new THREE.Clock()</code> 을 통해 시계 객체를 생성하고 <code>getElapsedTime()</code> 을 통해 시계가 생성되고 나서 얼마나 지났는지에 대한 값을 받아올 수 있다.</p>\n<p>이 값으로도 오브젝트를 회전할 수 있다.</p>\n<pre><code class=\"language-javascript\">const clock = new THREE.Clock()\nconst tick = () => {\n    const elapsedTime = clock.getElapsedTime()\n\n    mesh.position.x = Math.cos(elapsedTime)\n    mesh.position.y = Math.sin(elapsedTime)\n}\n\ntick()\n</code></pre>\n<p>코사인과 사인 베지어를 이용해서 오브젝트의 회전애니메이션을 주게되면 좀 더 역동적인 애니메이션을 볼 수 있다.</p>\n<pre><code class=\"language-javascript\">const clock = new THREE.Clock()\nconst tick = () => {\n    const elapsedTime = clock.getElapsedTime()\n\n    camera.position.x = Math.cos(elapsedTime)\n    camera.position.y = Math.sin(elapsedTime)\n    camera.lookAt(mesh.position)\n}\n\ntick()\n</code></pre>\n<p>오브젝트는 그대로두고 카메라에 회전을 걸고 <code>lookAt()</code> 으로 오브젝트를 중심으로 카메라를 회전하게 할 수도 있다.</p>\n<pre><code class=\"language-javascript\">import gsap from 'gsap'\n\ngsap.to(mesh.position, { duration: 1, delay: 1, x: 2 })\n\nconst tick = () =>{\n    renderer.render(scene, camera)\n    window.requestAnimationFrame(tick)\n}\n\ntick()\n</code></pre>\n<p><a href=\"https://greensock.com/gsap/\">GSAP</a> 라이브러리를 이용하면 좀 더 쉽게 애니메이션을 설정 할 수 있다.</p>\n<h3>전체코드</h3>\n<h3>전체 코드</h3>\n<pre><code class=\"language-javascript\">import './style.css'\nimport * as THREE from 'three'\nimport gsap from 'gsap'\n\n// Canvas\nconst canvas = document.querySelector('canvas.webgl')\n\n// Scene\nconst scene = new THREE.Scene()\n\n// Object\nconst geometry = new THREE.BoxGeometry(1, 1, 1)\nconst material = new THREE.MeshBasicMaterial({ color: 0xff0000 })\nconst mesh = new THREE.Mesh(geometry, material)\nscene.add(mesh)\n\n// Sizes\nconst sizes = {\n    width: 800,\n    height: 600\n}\n\n// Camera\nconst camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height)\ncamera.position.z = 3\nscene.add(camera)\n\n// Renderer\nconst renderer = new THREE.WebGLRenderer({\n    canvas: canvas\n})\nrenderer.setSize(sizes.width, sizes.height)\nrenderer.render(scene, camera)\n\nconst clock = new THREE.Clock()\n\n// let time = Date.now()\n\ngsap.to(mesh.position, {duration: 1, delay: 1, x: 2})\ngsap.to(mesh.position, {duration: 1, delay: 2, x: 0})\n\nconst tick = () => {\n    /*\n        //timestamp\n        const currentTime = Date.now()\n        const deltaTime = currentTime - time\n        time = currentTime\n\n        mesh.rotation.y += 0.001 * deltaTime\n    */\n\n        const elapsedTime = clock.getElapsedTime()\n    camera.position.x = Math.cos(elapsedTime)\n    camera.position.y = Math.sin(elapsedTime)\n    camera.lookAt(mesh.position)\n\n    renderer.render(scene, camera)\n    window.requestAnimationFrame(tick)\n}\n\ntick()\n</code></pre>\n<h2>스터디내용</h2>","frontmatter":{"date":"2021-05-06","path":"/posting/threejs-journey-06-animation","title":"threejs-journey 06-Animation","description":"three.js를 이용한 애니메이션효과 적용","tags":["three.js"]}}},"pageContext":{"pagePath":"/posting/threejs-journey-06-animation"}},"staticQueryHashes":["3454785627","63159454","987710685"]}