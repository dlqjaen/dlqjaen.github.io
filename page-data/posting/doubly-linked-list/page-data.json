{"componentChunkName":"component---src-components-posting-tsx","path":"/posting/doubly-linked-list","result":{"data":{"markdownRemark":{"html":"<h1>이중연결리스트 (Doubly Linked List)</h1>\n<ul>\n<li>기본적으로 연결리스트와 같이 떨어져있는 데이터를 연결해서 관리하는 데이터구조</li>\n<li>연결리스트와 다르게 양방향으로 연결되어서 노드 탐색 및 추가/삭제가 가능하다.</li>\n</ul>\n<h2>구현</h2>\n<pre><code class=\"language-javascript\">class Node {\n  constructor(data, next = null, prev = null) {\n    this.data = data\n    this.next = next\n    this.prev = prev\n  }\n}\n\nclass DoublyLinkedList {\n  constructor(data) {\n    this.node = new Node(data)\n    this.lastNode = this.node\n  }\n  getList() {\n    let pointer = this.node\n    let list = []\n    while (pointer) {\n      list.push(pointer.data)\n      pointer = pointer.next\n    }\n    return list\n  }\n  add(data) {\n    if (this.node === null) {\n      this.node = new Node(data)\n      this.lastNode = this.node\n    } else {\n      let pointer = this.node\n      while (pointer.next) {\n        pointer = pointer.next\n      }\n      const newNode = new Node(data)\n      this.pointer.next = newNode\n      newNode.prev = pointer\n      this.lastNode = newNode\n    }\n  }\n  addBefore(data, beforeData) {\n    if (this.node === null) {\n      this.node = new Node(data)\n      this.lastNode = this.node\n    } else {\n      let pointer = this.node\n      while (pointer.data !== beforeData) {\n        pointer = this.node.prev\n      }\n      if (pointer === this.node) {\n        const newNode = new Node(data, this.node)\n        this.node.prev = newNode\n        this.node = newNode\n      } else {\n        const newNode = new Node(data, this.node, this.node.prev)\n        this.node.prev.next = newNode\n        this.node.prev = newNode\n      }\n    }\n  }\n  addAfter(data, afterData) {\n    if (this.node === null) {\n      this.node = new Node(data)\n      this.lastNode = this.node\n    } else {\n      let pointer = this.node\n      while(pointer.data !== afterData) {\n        pointer = pointer.next\n      }\n      if (pointer === this.lastNode) {\n        const newNode = new Node(data, null, this.lastNode)\n        this.lastNode.next = newNode\n        this.lastNode = newNode\n      } else {\n        const newNode = new Node(data, this.lastNode.next, this.lastNode)\n        this.lastNode.next.prev = newNode\n        this.lastNode.next = newNode\n      }\n    }\n  }\n  delete(data) {\n    if (this.node === null) { return }\n    if (this.node.data === data) {\n      this.node = this.node.next\n      this.node.prev = null\n    } else {\n      let pointer = this.node\n      while (pointer.data !== data) {\n        pointer = pointer.next\n      }\n      if (pointer === this.lastNode) {\n        this.lastNode = this.lastNode.prev\n        this.lastNode.next = null\n      } else {\n        this.node.prev.next = this.node.next\n        this.node.next.prev = this.node.prev\n      }\n    }\n  }\n  searchFromFirst(data) {\n    let pointer = this.node\n    while(pointer.data !== data) {\n      pointer = pointer.next\n    }\n    return pointer === null\n  }\n  searchFromLast(data) {\n    let pointer = this.lastNode\n    while(pointer.data !== data) {\n      pointer = pointer.prev\n    }\n    return pointer === null\n  }\n}\n\nconst instance = new DoublyLinkedList(0)\ninstance.getList() // [0]\ninstance.add(2)\ninstance.getList() // [0, 2]\ninstance.delete(0)\ninstance.searchFromFirst(0) // false\ninstance.searchFromLast(0) // false\ninstance.searchFromFirst(2) // true\ninstance.searchFromLast(2) // true\ninstance.getList() // [2]\ninstance.addBefore(1, 2)\ninstance.getList() // [1, 2]\ninstance.addAfter(0, 1)\ninstance.getList() // [1, 0, 2]\n</code></pre>","frontmatter":{"date":"2021-05-05","path":"/posting/doubly-linked-list","title":"이중연결리스트","description":"기본적으로 연결리스트와 같이 떨어져있는 데이터를 연결해서 관리하는 데이터구조, 연결리스트와 다르게 양방향으로 연결되어서 노드 탐색 및 추가/삭제가 가능하다.","tags":["JS","dataStructure"]}}},"pageContext":{"pagePath":"/posting/doubly-linked-list"}},"staticQueryHashes":["3454785627","63159454","987710685"]}