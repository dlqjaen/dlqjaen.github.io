{"componentChunkName":"component---src-components-posting-tsx","path":"/posting/threejs-journey-05-transfrom-objects","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://threejs-journey.xyz/lessons/5\">Link</a></p>\n<ul>\n<li>04강의에서 webpack을 이용하여 three.js를 연결하도록 했었다.(04강 Webpack설정은 따로 정리하지 않음.)</li>\n<li><code>position</code> (개체 이동), <code>scale</code> (개체 크기 조정), <code>rotation</code> (개체 회전), <code>quaternion</code> (객체를 회전하기 위해; 나중에 자세히 알아보기)을 이용하면 오브젝트를 이동, 크기조절, 회전 할 수 있다.</li>\n<li><em>주의</em> 이런 조절은  <code>renderer.render()</code>이 선언되기 전에 되어야 합니다.</li>\n</ul>\n<h3>Position</h3>\n<pre><code class=\"language-javascript\">const geometry2 = new THREE.BoxGeometry(1, 1, 1)\nconst material2 = new THREE.MeshBasicMaterial({ color: 'blue' })\nconst mesh2 = new THREE.Mesh(geometry2, material2)\nmesh2.position.x = 1\nmesh2.position.y = 2\nmesh2.position.z = 2\nscene.add(mesh2)\nmesh.position.set(0.7, -0.6, 1)\n</code></pre>\n<p><code>mesh.position.set</code> 을 이용하면<code>position</code>의 <code>x, y, z</code> 값을 한 번에 설정 할 수 있다.</p>\n<pre><code class=\"language-javascript\">mesh.position.length()\n</code></pre>\n<p>Vactor의 길이를 구할 수 있다고 하지만 정확히 이해하지 못함.</p>\n<pre><code class=\"language-javascript\">mesh.position.distanceTo(camera.position)\n</code></pre>\n<p><code>distanceTo</code> 를 이용하면 카메라와 오브젝트 사이의 <code>Vactor3에서의 거리</code>를 구할 수 있다.</p>\n<p><em>주의</em> 카메라를 생성한 후에 선언해야 제대로 동작한다.</p>\n<pre><code class=\"language-javascript\">mesh.position.normalize()\n</code></pre>\n<p>Vactor의 값을 1로 줄이고 방향을 고정하도록 값을 정규화 시킨다고 하지만 제대로 이해 못 함.</p>\n<h3>Scale</h3>\n<pre><code class=\"language-javascript\">mesh.scale.x = 2\nmesh.scale.y = 0.25\nmesh.scale.z = 0.5\n</code></pre>\n<p><code>scale</code> 을 이용하면 축별 크기를 조절 할 수 있다.</p>\n<h3>Rotate</h3>\n<pre><code class=\"language-javascript\">mesh.rotation.reorder('YXZ')\nmesh.rotation.y = Math.PI * 0.25\nmesh.rotation.x = Math.PI * 0.25\n</code></pre>\n<p><code>rotate</code> 를 이용하면 오브젝트에 회전을 줄 수 있다.</p>\n<p><code>주의</code> rotate는 먼저 적용되는 축에 따라 다음에 적용되는 축의 방향이 변한다.</p>\n<p><code>reorder</code> 를 사용하면 축이 변경될 우선순위를 재설정 할 수 있다. <code>(대문자로 입력해야 함!)</code></p>\n<p>축 전환으로인해 계산이 어려울 수 있는데 축 계산없이 쉽게 회전을 줄 수 있는 것이 <code>quaternion</code> 라고 한다.</p>\n<h3>Group</h3>\n<pre><code class=\"language-javascript\">const group = new THREE.Group()\ngroup.scale.y = 2\ngroup.rotation.y = 0.2\ngroup.position.x = 1\nscene.add(group)\n\nconst cube1 = new THREE.Mesh(\n    new THREE.BoxGeometry(1, 1, 1),\n    new THREE.MeshBasicMaterial({ color: 'yellow' })\n)\ncube1.position.x = -1.5\ngroup.add(cube1)\n\nconst cube2 = new THREE.Mesh(\n    new THREE.BoxGeometry(1, 1, 1),\n    new THREE.MeshBasicMaterial({ color: 'green' })\n)\ncube2.position.x = 0\ngroup.add(cube2)\n\nconst cube3 = new THREE.Mesh(\n    new THREE.BoxGeometry(1, 1, 1),\n    new THREE.MeshBasicMaterial({ color: 'blue' })\n)\ncube3.position.x = 1.5\ngroup.add(cube3)\n</code></pre>\n<p><code>THREE.Group()</code> 을 이용하면 여러 오브젝트를 그룹으로 묶을 수 있다.</p>\n<p><code>scene.add(group)</code> 으로 화면에 그룹을 추가해줘야 그룹에 추가한 오브젝트들이 보이게된다.</p>\n<p>각 오브젝트를 생성하고 <code>group.add()</code> 를 이용하여 그룹에 지정해준다. 이때 같은위치에 오브젝트가 겹치게 된다면 나중에 선언된 오브젝트가 보이게 된다.</p>\n<h3>축 가이드</h3>\n<pre><code class=\"language-javascript\">const axesHelper = new THREE.AxesHelper(2)\nscene.add(axesHelper)\n</code></pre>\n<p><code>THREE.AxesHelper</code> 를 이용하면 <code>x, y, z</code>축에 해당하는 축 가이드를 추가할 수 있다. 매개변수로 <code>행의 길이</code>를 정할 수 있다.</p>\n<h3>전체 코드</h3>\n<pre><code class=\"language-javascript\">import './style.css'\nimport * as THREE from 'three'\n\nconst scene = new THREE.Scene()\nconst geometry = new THREE.BoxGeometry(1, 1, 1)\nconst material = new THREE.MeshBasicMaterial({ color: 0xff00000 })\nconst mesh = new THREE.Mesh(geometry, material)\nscene.add(mesh)\n\nconst geometry2 = new THREE.BoxGeometry(1, 1, 1)\nconst material2 = new THREE.MeshBasicMaterial({ color: 'blue' })\nconst mesh2 = new THREE.Mesh(geometry2, material2)\nmesh2.position.x = 1\nmesh2.position.y = 2\nmesh2.position.z = 2\nscene.add(mesh2)\n\nconst sizes = {\n  width: 800,\n  height: 600\n}\nconst camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height)\ncamera.position.z = 3\ncamera.position.x = 0\ncamera.position.y = 0\ncamera.lookAt(new THREE.Vector3(0, -1, 0))\nscene.add(camera)\n\nmesh.position.set(0.7, -0.6, 1)\nconsole.log(mesh.position.normalize())\nconsole.log(mesh.position.distanceTo(camera.position))\n\n// mesh.scale.x = 2\n// mesh.scale.y = 0.25\n// mesh.scale.z = 0.5\n\nmesh.rotation.reorder('YXZ')\nmesh.rotation.y = Math.PI * 0.25\nmesh.rotation.x = Math.PI * 0.25\n\nconst group = new THREE.Group()\ngroup.scale.y = 2\ngroup.rotation.y = 0.2\ngroup.position.x = 1\nscene.add(group)\n\nconst cube1 = new THREE.Mesh(\n    new THREE.BoxGeometry(1, 1, 1),\n    new THREE.MeshBasicMaterial({ color: 'yellow' })\n)\ncube1.position.x = -1.5\ngroup.add(cube1)\n\nconst cube2 = new THREE.Mesh(\n    new THREE.BoxGeometry(1, 1, 1),\n    new THREE.MeshBasicMaterial({ color: 'green' })\n)\ncube2.position.x = 0\ngroup.add(cube2)\n\nconst cube3 = new THREE.Mesh(\n    new THREE.BoxGeometry(1, 1, 1),\n    new THREE.MeshBasicMaterial({ color: 'blue' })\n)\ncube3.position.x = 1.5\ngroup.add(cube3)\n\nconst axesHelper = new THREE.AxesHelper(2)\nscene.add(axesHelper)\n\nconst canvas = document.querySelector('canvas.webgl')\n\nconst renderer = new THREE.WebGLRenderer({ canvas })\nrenderer.setSize(sizes.width, sizes.height)\nrenderer.render(scene, camera)\n</code></pre>\n<h2>스터디 내용</h2>\n<ul>\n<li>이번 강의의 중심은 여러 mesh를 묶은 하나의 그룹을 만들 수 있다는 것 같았다.</li>\n<li>또 다른 내용은 rotaion과 <a href=\"https://threejs.org/docs/#api/en/math/Quaternion\">Quaternion</a> 을 이용한 회전이었는데, rotaion은 x, y, z축 중 어떤 축을 먼저 회전시키냐에 따라서 나머지 축도 영향을 받게되는데 Quaternion은 축변환이 없이 회전시킬 수 있으나 수학적 공식이 필요하고 어려워 나중에 다룬다고 한다.(정말?)</li>\n<li>position은 <a href=\"https://threejs.org/docs/#api/en/math/Vector3\">Vector3</a> 클래스 의 인스턴스라고 했는데  Vector3에 대해 좀 더 공부해볼 필요가 있을 것 같다.</li>\n<li><code>AxesHelper</code>를 이용하면 중심을 표시 할 수 있다. (3강 스터디때 필요성을 언급)</li>\n</ul>","frontmatter":{"date":"2021-05-02","path":"/posting/threejs-journey-05-transfrom-objects","title":"threejs-journey 05-transform-objects","description":"three.js를 이용한 물체의 이동, 크기변화, 그룹화를 공부해보자!","tags":["three.js"]}}},"pageContext":{"pagePath":"/posting/threejs-journey-05-transfrom-objects"}},"staticQueryHashes":["3454785627","63159454","987710685"]}