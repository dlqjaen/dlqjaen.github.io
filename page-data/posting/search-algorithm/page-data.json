{"componentChunkName":"component---src-components-posting-tsx","path":"/posting/search-algorithm","result":{"data":{"markdownRemark":{"html":"<h2>탐색 알고리즘</h2>\n<h3>선형 탐색</h3>\n<p>처음부터 하나씩 살펴가면서 원하는 값을 찾는 알고리즘<br>\n크기가 작은 배열에서 사용하기 좋다.</p>\n<p>시간복잡도: <code>O(n)</code></p>\n<h3>이진 탐색</h3>\n<p>리스트의 중간 값을 먼저보고 원하는 값보다 큰지 작은지를 비교한 다음, 크다면 큰 부분에서 다시 가운데 값, 작다면 작은 부분에서 가운데 값을 다시 비교해가며 원하는 값을 찾는 알고리즘</p>\n<ul>\n<li>전제조건: 리스트는 정렬이 되어있어야 한다.</li>\n</ul>\n<p>시간복잡도: <code>O(logN)</code></p>\n<h3>해시 탐색</h3>\n<p>데이터를 알 수 있는 특정 인덱스에 저장해 둔다.</p>\n<p>선형, 이진 탐색과 달리 애초에 데이터를 저장 할 때부터 우리가 바로 찾을 수 있도록 인덱싱하는 공간에 값을 저장하는 방식</p>\n<pre><code class=\"language-javascript\">/*\n  숫자의 첫번째 수를 인덱스로 사용하는 경우\n  ex) 32는 3번 인덱스에 저장\n*/\n\nconst index = ['', '', '', 32]\n</code></pre>\n<p>만약 값이 겹치는 경우 바로 다음 인덱스에 값을 저장한다.</p>\n<p>단점, 값의 크기만큼 빈 공간을 만들어야해서 <code>공간의 복잡도가 증가</code>한다.<br>\n그렇기 때문에 공간을 최소한으로 만들 수 있도록 하는것이 관건이다.</p>","frontmatter":{"date":"2020-11-06","path":"/posting/search-algorithm","title":"탐색 알고리즘(선형, 이진, 해시)","description":"","tags":["Algorithm"]}}},"pageContext":{"pagePath":"/posting/search-algorithm"}},"staticQueryHashes":["3454785627","63159454","987710685"]}