{"componentChunkName":"component---src-components-posting-tsx","path":"/posting/this","result":{"data":{"markdownRemark":{"html":"<h2>This</h2>\n<ul>\n<li>this는 기본적으로 Window이다.</li>\n<li>this는 실행문맥이다.</li>\n<li>\n<pre><code class=\"language-javascript\">const obj = {\na: () => { console.log(this) }\n}\nobj.a() // obj\n</code></pre>\n<p>객체의 메서드를 호출할 때 this를 내부적으로 바꿔준다.</p>\n</li>\n<li>\n<pre><code class=\"language-javascript\">const b = abj.a\nb() // Window\n</code></pre>\n<p>호출 할 때, 호출하는 함수가 객체의 함수인지, 그냥 함수인지가 중요</p>\n</li>\n<li>this를 바꾸는 3가지 메서드:  <code>bind</code>, <code>call</code>, <code>apply</code></li>\n<li>\n<pre><code class=\"language-javascript\">function Test(subject, grade) {\nthis.subject = subject\nthis.grade = grade\n}\nTest.prototype.confirm = function() {\nconsole.log(this.subject, this.grade)\n}\n\nTest('영어', 80)\nconsole.log(window.subject, window.grade) // '영어' 80\n\nconst test = new Test('국어', 100)\ntest.confirm() // '국어' 100\n</code></pre>\n<p>생성자 함수도 함수이기 때문에 <code>new</code> 로 생성하지 않고 함수호출로 실행하게 되면 내부의 this는 Window를 가리키게되고 Window에 데이터를 할당하게 된다.</p>\n</li>\n</ul>\n<h3>Arrow Function</h3>\n<ul>\n<li>에로우 펑션에는 <code>this</code>가 존재하지 않는다. 대신 화살표 함수를 둘러싸는 렉시컬 범위의 this가 사용된다.</li>\n<li>에로우 펑션은 레시컬 범위의 <code>this</code>를 가지기 때문에 <code>strict 모드</code>라도 전역 객체를 this로 가질 수 있다.</li>\n</ul>","frontmatter":{"date":"2020-11-10","path":"/posting/this","title":"This","description":"","tags":["javascript"]}}},"pageContext":{"pagePath":"/posting/this"}},"staticQueryHashes":["3454785627","63159454","987710685"]}