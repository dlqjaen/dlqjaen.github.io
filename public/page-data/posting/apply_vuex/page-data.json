{"componentChunkName":"component---src-components-posting-tsx","path":"/posting/apply_vuex","result":{"data":{"markdownRemark":{"html":"<h2>Vuex 적용하기</h2>\n<p>Vue를 적용하면서 \"각 기능별로 컴포넌트를 만들어 재사용하겠다!\"라는 큰 포부를 가지고 작업을 진행했지만 직면하게되는 몇가지 문제점들이 있었습니다.</p>\n<ol>\n<li>기능별 컴포넌트를 만들면서 컴포넌트별로 공유되어야하는 상태값들이 많다.\n(ex. 메모 컴포넌트와 입력 컴포넌트의 상태에 따라 등록버튼의 활성화...)</li>\n<li>위의 문제를 해결하기위해 사용했던 <a href=\"http://vuejs.kr/jekyll/update/2017/02/13/vuejs-eventbus/\">Event Bus</a>의 경우 이벤트의 이름을 매번 겹치지않게 해줘야한다.\n(HTML id값 처럼)</li>\n<li>Event Bus로 상태를 관리하게 되면 유지 보수를 할 경우 파편적으로 나뉘어져 있는 코드를 파악하는 비용이 크다.</li>\n</ol>\n<p>이러한 이유로 각 컴포넌트의 종속관계에 영향없이 쉽게 상태값을 공유하고 코드의 관리도 한 번에 할 수 있는 <a href=\"https://vuex.vuejs.org/kr/\">Vuex</a>를 적용하기로 했습니다.</p>\n<h4>Vuex의 플로우</h4>\n<p>Vuex를 사용하기 전에 Vuex가 어떤 플로우로 동작하는지 먼저 알아보겠습니다.</p>\n<p>Vuex에서는 4개의 모듈로 구성되어있습니다.</p>\n<ol>\n<li>State</li>\n<li>Getter</li>\n<li>Mutations</li>\n<li>Actions</li>\n</ol>\n<h5>State</h5>\n<p>​\t컴포넌트에서 공유할 데이터(상태값)가(이) 들어가는 모듈입니다.</p>\n<h5>Getter</h5>\n<p> \tState에 있는 데이터를 가져오는 함수를 모아놓는 모듈입니다.</p>\n<h5>Mutations</h5>\n<p>​\tState에 있는 데이터를 변경하는 함수를 모아놓은 모듈입니다.</p>\n<p>​\t동기적으로 데이터를 변경할 경우 사용할 수 있습니다.</p>\n<h5>Actions</h5>\n<p>​\t이벤트를 감지하고 Mutations에 있는 적절한 함수를 실행시키는 함수를 모아놓은 모듈입니다.</p>\n<p>​\tAPI호출 이후 비동기적으로 데이터를 변경해야하는 경우 사용됩니다.</p>\n<p>이렇게 놓고보니 State에 있는 데이터를 바로 접근해서 가져오면 되지않나? 데이터 변경도 Mutations을 거치지 않고 State에 바로 접근해서 변경하면 되지 않나? 라는 생각이 먼저 들었습니다.</p>\n<p>하지만 Vuex에서는 직접적으로 데이터에 접근하는 것을 지양하고 있습니다. 그 이유는 Getter, Mutations, Actions이란 절차를 거치면서 코드의 흐름을 파악하기 쉬워지고 devtools의 기록이 남아 시간의 흐름에 따라 디버깅하기 편하기 때문입니다.</p>\n<p>결국 Vuex는 State에 데이터가 저장되고 Component에서는 Getter를 통해 State의 데이터를 가져오고 데이터를 변경하기 위해서는 Actions혹은 Mutations를 이용해  State의 데이터를 변경하게 됩니다.\n(State -> Getter -> Component -> Actions(동기)/Mutations(비동기) -> State)</p>\n<p><img src=\"https://vuex.vuejs.org/vuex.png\" alt=\"vuex flow\"></p>\n<h4>폴더 구성</h4>\n<pre><code>&#x3C;Project>\n    |-- __mocks__\n    |-- __test__\n    |       `-- store.test.js\n    |-- common\n    |-- components\n    |-- *store*\n    |      |-- index.js (Vue에서 Vuex를 사용하겠다는 선언)\n    |      |-- actions.type.js (Vuex의 Actions로 사용될 함수명 모음)\n    |      |-- mutations.type.js (Vuex의 Mutations으로 사용될 함수명 모음)\n    |      `-- &#x3C;project>_module.js (Vuex의 Store역할)\n    |\n    `-- &#x3C;project>.js (Vuex 적용)\n</code></pre>\n<h4>index.js</h4>\n<p>Vuex를 모듈로서 사용하기 위해서는 우선적으로 Vue에서 Vuex를 사용한다는 선언이 필요합니다.</p>\n<pre><code class=\"language-javascript\">import Vue from 'vue/dist/vue.common.js'\nimport Vuex from 'vuex'\n\nVue.use(Vuex);\n</code></pre>\n<p>이렇게 선언을 하고 vuex에서 저장소로 사용할 모듈을 지정 해줍니다.</p>\n<pre><code class=\"language-javascript\">import example from './example_module.js'\n\nexport default new Vuex.Store({\n  modules: {\n    example\n  }\n});\n</code></pre>\n<p>이제 Vuex를 사용할 준비가 되었습니다.</p>\n<h4>actions.type.js</h4>\n<p>Vuex에서 사용될 actions 함수명을 모아놓고 export합니다.</p>\n<pre><code class=\"language-javascript\">export const callDetailData = 'callDetailData'\n</code></pre>\n<p>이렇게 actions의 함수를 모아놓지 않고 Vuex에서 함수를 선언해서 바로 사용 할 수 있지만 이렇게 따로 분리하는 이유는 유지 보수를 위해서 입니다. Vuex란 하나의 저장소를 수많은 컴포넌트들이 접근하기 때문에 데이터를 get/set하기 위해서는 수많은 함수가 만들어질 수 밖에 없습니다. 이 때 사용되고 있는 함수를 편하게 인덱스하기 위해서 입니다.</p>\n<p>사실 지금은 책자의 Index(목차) 같은 역할을 할 뿐이라 Vuex에서 함수가 많아졌을때 비대해지는건 그대로입니다. 추후 Vuex가 너무 비대해지면 로직을 따로 분리할 때 여기에 actions 함수들만 분리할 수도 있습니다.</p>\n<h4>mutations.type.js</h4>\n<p>Vuex에서 사용될 mutations 함수명을 모아놓고 export합니다.</p>\n<pre><code class=\"language-javascript\">export const setDetailData = 'setDetailData'\nexport const setLoadingStatus = 'setLoadingStatus'\n</code></pre>\n<p>mutations 함수를 따로 분리하는 이유는 actions.type.js와 마찬가지로 유지 보수를 편하게 하기 위해서 입니다. 추후 mutations 함수들만 분리할 수도 있습니다.</p>\n<h4>Project_modules.js</h4>\n<p>Vuex에서 Store 역할을 합니다.(핵심)</p>\n<pre><code class=\"language-javascript\">import {\n  callDetailData\n} from './actions.type'\n\nimport {\n  setDetailData,\n  setLoadingStatus\n} from './mutations.type'\n\nimport ApiService from '@/js/pro_proofreading/common/api.service'\nimport {Common} from '@/js/common/Common'\n\nconst state = {\n  detailData: null,\n  loading: true,\n  req_id: window.req_id\n}\n\nconst getters = {\n  getDetailData (state) {\n    return state.detailData\n  },\n  getLoading (state) {\n    return state.loading\n  }\n}\n\nconst mutations = {\n  [setDetailData](state, payload) {\n    state.detailData = payload.detailData\n  },\n  [setLoadingStatus](state, payload) {\n    state.loading = payload.loadingStatus\n  },\n}\n\nconst actions = {\n  async [callDetailData](context, payload) {\n    await ApiService.getProProofreadDetailData(payload.req_id)\n      .then(res => {\n        context.commit(setDetailData, { detailData: res })\n        context.commit(setLoadingStatus, { loadingStatus: false })\n      })\n      .catch((error) => {\n        Common.methods.__error__(error)\n      })\n  }\n}\n\nexport default {\n  state,\n  getters,\n  mutations,\n  actions\n}\n</code></pre>\n<h4>Project.js</h4>\n<p>Vuex의 Store를 Vue객체에 주입해주면 하위 컴포넌트들에서도 Store에 접근 할 수 있게 됩니다.</p>\n<pre><code class=\"language-javascript\">import Vue from 'vue/dist/vue.common.js'\nimport store from './store'\n\nnew Vue({\n  el: '#project'\n  store,\n})\n</code></pre>\n<p>이렇게 사용할 수 있는 이유는 index.js에서 <code>Vue.use(Vuex)</code>로 선언해줬기 때문에 가능합니다.</p>\n<h4>테스트</h4>\n<pre><code class=\"language-javascript\">import {shallowMount, mount, createLocalVue} from '@vue/test-utils'\nimport _ from 'underscore'\nimport {axios} from '@/js/crowd_proofreading/__mocks__'\nimport {mockAPIData} from '@/js/pro_proofreading/__mocks__'\nimport ProProofreadingModule from '@/js/pro_proofreading/store/pro.proofreading.module'\nimport { callDetailData } from '@/js/pro_proofreading/store/actions.type'\nimport { setDetailData, setLoadingStatus } from '@/js/pro_proofreading/store/mutations.type'\nimport Vuex from 'vuex'\n\nconst localVue = createLocalVue()\nlocalVue.use(Vuex)\n\ndescribe('store 확인', () => {\n  let store = null\n  const req_id = 1\n  beforeEach(async () => {\n    store = new Vuex.Store({\n      state: _.extend({}, ProProofreadingModule.state),\n      getters: ProProofreadingModule.getters,\n      mutations: ProProofreadingModule.mutations,\n      actions: ProProofreadingModule.actions\n    })\n    axios.get.mockImplementation((url) => {\n      let data = {}\n      if (url === '/api/1.3/pf/pro/1') {\n        data = mockAPIData['/api/1.3/pf/pro/:req_id'].default\n      }\n      return Promise.resolve({data})\n    })\n  })\n</code></pre>\n<h4>규칙</h4>\n<ul>\n<li>2개 이상의 컴포넌트에서 같이 사용하는 데이터일 경우 Vuex로 관리한다.</li>\n</ul>\n<h4>생각해볼 점</h4>\n<ul>\n<li>Vuex로 관리되는 Actions, Mutations의 길이가 관리가 안될 정도로 길어진다면 함수 자체를 모듈로 따로 뺄 수도 있을 것 같다.</li>\n<li>왜 Vuex에서는 mutation, action 이란 이름으로 사용할까?\n(아마도 state를 변경한다는 의미에서 mutation이라고 했을 것 같다. mutaion을 getter처럼 setter로 했다면 Action을 어떤 이름으로 불러야 했을까?)</li>\n</ul>","frontmatter":{"date":"2019-01-26","path":"/posting/apply_vuex","title":"Apply Vuex","description":"Vuex를 도입하게된 배경과 적용하는 과정 그리고 생각해볼 점을 정리","tags":["service"]}}},"pageContext":{"pagePath":"/posting/apply_vuex"}},"staticQueryHashes":["3454785627","63159454","987710685"]}